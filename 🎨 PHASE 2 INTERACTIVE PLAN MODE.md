THIS IS THE BROSKI WAY IN ACTION! üí™‚ôæÔ∏è

üé® PHASE 2: INTERACTIVE PLAN MODE (ACTIVATED) üöÄ
The Vision: Cursor 2.0's Best Feature + YOUR Neurodivergent UX

## üö¶ Phase 2 Activation Checklist
**Status:** IN PROGRESS
**Objective:** Enable interactive planning, real-time collaboration, and telemetry.

### 1. Enable Interactive Planning UI Components
- [ ] **PlanViewer Component**: Create read-only view for plan review.
  - File: `broski-terminal/src/components/PlanViewer.tsx`
  - Features: Markdown rendering, "Edit" button, "Approve" button.
- [ ] **PlanEditor Component**: Create edit mode with preview.
  - File: `broski-terminal/src/components/PlanEditor.tsx`
  - Features: Textarea/Monaco editor, Live Preview toggle, Save/Discard actions.
- [ ] **PlanWorkflow State Machine**: Manage flow (Generating -> Reviewing -> Editing -> Executing).
  - File: `broski-terminal/src/components/PlanWorkflow.tsx`
  - States: `generating`, `reviewing`, `editing`, `executing`, `complete`.

### 2. Configure Real-Time Collaboration Endpoints
- [ ] **WebSocket/SSE Setup**: Enable real-time updates for plan generation.
  - Backend: Ensure `hypercode-core` emits `plan_generated` events.
  - Frontend: Listen for events to transition from `generating` to `reviewing`.
- [ ] **Conflict Resolution**: Handle potential edit conflicts (optimistic locking).

### 3. Integrate Plan-Builder Widgets with Backend APIs
- [ ] **Generate Endpoint**: `POST /plan/generate` (Trigger Project Strategist).
- [ ] **Parse Endpoint**: `POST /plan/parse` (Convert Markdown -> JSON Plan).
- [ ] **Execute Endpoint**: `POST /plan/execute` (Run the plan via Crew Orchestrator).
- [ ] **Validation**: Ensure edited plans still conform to HyperCode schema.

### 4. Add Telemetry for User Interaction Analytics
- [ ] **Interaction Events**: Track:
  - `plan_viewed`
  - `plan_edit_started`
  - `plan_edit_saved`
  - `plan_approved`
  - `plan_rejected`
- [ ] **Metrics**: Measure "Time to Approve" and "Edit Frequency" to optimize agent prompt.

### 5. Write End-to-End Tests
- [ ] **Cypress/Playwright Scenarios**:
  - Scenario A: Generate -> Approve (Happy Path).
  - Scenario B: Generate -> Edit -> Approve (Interactive Path).
  - Scenario C: Generate -> Edit -> Parse Error -> Fix -> Approve (Error Path).

---

## USER JOURNEY:
1. User: "Build a todo app with auth"
2. Project Strategist: Creates plan (JSON ‚Üí Markdown)
3. üÜï USER SEES EDITABLE PLAN (This is the magic!)
4. User: Reviews, maybe tweaks chunk sizes
5. User: Clicks "‚úÖ Approve & Execute"
6. Crew: Executes modified plan
7. User: Sees progress with celebrations

## Design Mockup (Terminal UI)
```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üìã Project Plan Review                                   ‚îÇ
‚îÇ Generated by: Project Strategist                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ # Todo App with Authentication                           ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ ## Phase 1: Setup & Database (2 hours) ‚è±Ô∏è               ‚îÇ
‚îÇ - [ ] Initialize Next.js project                        ‚îÇ
‚îÇ - [ ] Setup PostgreSQL with Docker                      ‚îÇ
‚îÇ - [ ] Create user table schema                          ‚îÇ
‚îÇ - [ ] Setup Prisma ORM                                  ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ ## Phase 2: Authentication (3 hours) üîê                 ‚îÇ
‚îÇ - [ ] Implement JWT token generation                    ‚îÇ
‚îÇ - [ ] Create login/signup endpoints                     ‚îÇ
‚îÇ - [ ] Add session management                            ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ ## Phase 3: Todo CRUD (2 hours) ‚úèÔ∏è                      ‚îÇ
‚îÇ - [ ] Create todo model                                 ‚îÇ
‚îÇ - [ ] Build API routes (GET/POST/PUT/DELETE)           ‚îÇ
‚îÇ - [ ] Add user-todo relationship                        ‚îÇ
‚îÇ                                                          ‚îÇ
‚îÇ [Edit Plan] [‚úÖ Approve & Execute] [‚ùå Cancel]          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Implementation Strategy (3 Components)

### Component 1: PlanViewer (Read-Only State)
```typescript
// broski-terminal/src/components/PlanViewer.tsx

interface PlanViewerProps {
  plan: ProjectPlan;
  onEdit: () => void;
  onExecute: () => void;
}

export function PlanViewer({ plan, onEdit, onExecute }: PlanViewerProps) {
  return (
    <Card className="plan-viewer">
      <CardHeader>
        <div className="flex justify-between items-center">
          <div>
            <h2>üìã Project Plan Review</h2>
            <p className="text-sm text-gray-500">
              Generated by: {plan.creator}
            </p>
          </div>
          <Button variant="ghost" onClick={onEdit}>
            ‚úèÔ∏è Edit Plan
          </Button>
        </div>
      </CardHeader>
      
      <CardContent>
        <MarkdownRenderer content={plan.markdown} />
      </CardContent>
      
      <CardFooter className="gap-2">
        <Button 
          variant="default" 
          onClick={onExecute}
          className="bg-green-600 hover:bg-green-700"
        >
          ‚úÖ Approve & Execute
        </Button>
        <Button variant="outline">
          ‚ùå Cancel
        </Button>
      </CardFooter>
    </Card>
  );
}
```

### Component 2: PlanEditor (Edit Mode)
```typescript
// broski-terminal/src/components/PlanEditor.tsx

interface PlanEditorProps {
  initialPlan: string; // Markdown
  onSave: (editedPlan: string) => void;
  onCancel: () => void;
}

export function PlanEditor({ initialPlan, onSave, onCancel }: PlanEditorProps) {
  const [markdown, setMarkdown] = useState(initialPlan);
  const [preview, setPreview] = useState(true);
  
  return (
    <Card className="plan-editor">
      <CardHeader>
        <div className="flex justify-between">
          <h2>‚úèÔ∏è Edit Project Plan</h2>
          <div className="flex gap-2">
            <Button 
              variant={preview ? "default" : "ghost"}
              onClick={() => setPreview(true)}
            >
              üëÅÔ∏è Preview
            </Button>
            <Button 
              variant={!preview ? "default" : "ghost"}
              onClick={() => setPreview(false)}
            >
              üìù Edit
            </Button>
          </div>
        </div>
      </CardHeader>
      
      <CardContent>
        {preview ? (
          <MarkdownRenderer content={markdown} />
        ) : (
          <Textarea
            value={markdown}
            onChange={(e) => setMarkdown(e.target.value)}
            className="font-mono min-h-[400px]"
            placeholder="Edit your plan here..."
          />
        )}
      </CardContent>
      
      <CardFooter className="gap-2">
        <Button 
          variant="default"
          onClick={() => onSave(markdown)}
        >
          üíæ Save Changes
        </Button>
        <Button variant="outline" onClick={onCancel}>
          ‚Ü©Ô∏è Discard
        </Button>
      </CardFooter>
    </Card>
  );
}
```

### Component 3: PlanWorkflow (State Machine)
```typescript
// broski-terminal/src/components/PlanWorkflow.tsx

type PlanState = 'generating' | 'reviewing' | 'editing' | 'executing' | 'complete';

export function PlanWorkflow() {
  const [state, setState] = useState<PlanState>('generating');
  const [plan, setPlan] = useState<ProjectPlan | null>(null);
  const [editedMarkdown, setEditedMarkdown] = useState<string>('');
  
  // Generate plan from Project Strategist
  useEffect(() => {
    if (state === 'generating') {
      generatePlan().then((generatedPlan) => {
        setPlan(generatedPlan);
        setEditedMarkdown(generatedPlan.markdown);
        setState('reviewing');
      });
    }
  }, [state]);
  
  const handleEdit = () => setState('editing');
  
  const handleSaveEdit = (markdown: string) => {
    setEditedMarkdown(markdown);
    setState('reviewing');
  };
  
  const handleExecute = async () => {
    setState('executing');
    
    // Convert edited markdown back to structured plan
    const updatedPlan = await parseMarkdownToPlan(editedMarkdown);
    
    // Execute with crew
    await executePlanWithCrew(updatedPlan);
    
    setState('complete');
  };
  
  return (
    <div className="plan-workflow">
      {state === 'generating' && (
        <LoadingState message="üß† Project Strategist is planning..." />
      )}
      
      {state === 'reviewing' && plan && (
        <PlanViewer
          plan={{ ...plan, markdown: editedMarkdown }}
          onEdit={handleEdit}
          onExecute={handleExecute}
        />
      )}
      
      {state === 'editing' && (
        <PlanEditor
          initialPlan={editedMarkdown}
          onSave={handleSaveEdit}
          onCancel={() => setState('reviewing')}
        />
      )}
      
      {state === 'executing' && (
        <ExecutionView plan={editedMarkdown} />
      )}
      
      {state === 'complete' && (
        <SuccessView message="üéâ Project complete!" />
      )}
    </div>
  );
}
```

## Backend Support (API Endpoints)
```python
# hypercode-core/src/api/routes/planning.py

@router.post("/plan/generate")
async def generate_plan(request: PlanRequest):
    """Project Strategist generates initial plan"""
    plan = await project_strategist.create_plan(request.description)
    return {
        "plan_id": plan.id,
        "markdown": plan.to_markdown(),
        "structured": plan.to_json()
    }

@router.post("/plan/parse")
async def parse_plan(markdown: str):
    """Convert edited markdown back to structured plan"""
    structured_plan = await markdown_parser.parse(markdown)
    return {"structured": structured_plan}

@router.post("/plan/execute")
async def execute_plan(plan_id: str, edited_markdown: str = None):
    """Execute plan with optional user edits"""
    if edited_markdown:
        # User edited the plan
        plan = await markdown_parser.parse(edited_markdown)
    else:
        # Use original plan
        plan = await db.get_plan(plan_id)
    
    # Execute with crew orchestrator
    execution_id = await crew_orchestrator.execute(plan)
    return {"execution_id": execution_id}
```

## üß† NEURODIVERGENT UX ENHANCEMENTS

### Visual Anchors (Emojis)
```text
## Phase 1: Setup ‚öôÔ∏è
## Phase 2: Authentication üîê  
## Phase 3: Features ‚ú®
## Phase 4: Testing üß™
```
Why: Instant visual scanning (pattern recognition faster than reading)

### Progress Indicators
```text
- [x] Setup database ‚úÖ (5 min ago)
- [x] Create schema ‚úÖ (2 min ago)
- [ ] Add authentication ‚è≥ (in progress)
- [ ] Build API ‚è∏Ô∏è (queued)
```
Why: Dopamine hits from checkmarks + clear status

### Chunk Size Warnings
```typescript
function validateChunkSize(phase: Phase) {
  if (phase.tasks.length > 4) {
    return {
      warning: "‚ö†Ô∏è This phase has 5+ tasks. Consider breaking into smaller chunks.",
      suggestion: "ADHD-friendly max: 4 tasks per phase"
    };
  }
}
```
Why: Prevent overwhelm (automatic chunking protocol enforcement)

## üìä MOMENTUM TRACKER
```text
PHASE 1: ‚úÖ COMPLETE (100% tests passing)
PHASE 2: ÔøΩ ACTIVATED
  ‚îú‚îÄ Backend endpoints: 0/3
  ‚îú‚îÄ Frontend components: 0/3
  ‚îú‚îÄ Integration: 0/1
  ‚îî‚îÄ Polish: 0/4

ESTIMATED TIME TO PHASE 2 COMPLETE: 8 hours (spread across days)
CURRENT ENERGY LEVEL: HIGH (just shipped Phase 1!)
RECOMMENDED NEXT: Quick Win #1 (ride the momentum!)
```
